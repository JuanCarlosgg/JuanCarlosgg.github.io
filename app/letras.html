<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<!--  three.js library -->
<script src='../libs/three.js/build/three.js'></script>
<!--  jsartookit -->
<script src='../libs/jsartoolkit5/build/artoolkit.min.js'></script>
<script src='../libs/jsartoolkit5/js/artoolkit.api.js'></script>
<!--  OBJLoader -->
<script src='../libs/js/loaders/OBJLoader.js'></script>
<script src='../libs/js/loaders/TGALoader.js'></script>
<script src='../libs/js/loaders/MTLLoader.js'></script>

<!--  threex -->
<script src="../libs/threex/threex-artoolkitsource.js"></script>
<script src="../libs/threex/threex-artoolkitcontext.js"></script>
<script src="../libs/threex/threex-arbasecontrols.js"></script>
<script src="../libs/threex/threex-armarkercontrols.js"></script>



<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
	<div style='position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
	</div>
	<script>

		var scene, camera, renderer, clock, deltaTime, totalTime;
		var arToolkitSource, arToolkitContext;
		var markerRoot1, markerRoot2, markerRoot3;
		var mesh1, mesh2;
		var escala;
		var letra_object = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'Ã‘', 'O', 'P', 'Q', 'R', 'S', 'U', 'V', 'W', 'X', 'Y', 'Z'];
		var array_letras_object = new Array();
		var array_marker_name2 = ['patt/Aazul.patt', 'patt/Agris.patt', 'patt/Cnegra.patt',
			'patt/Crosa.patt', 'patt/Engra.patt', 'patt/Hnegra.patt', 'patt/Onegra.patt'];
		var array_marker_name = ['patt/Cnegra.patt','patt/Aazul.patt',];

		var array_marker = new Array();
		initialize();
		animate();
		function initialize() {
			scene = new THREE.Scene();
			let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
			scene.add(ambientLight);

			camera = new THREE.Camera();
			scene.add(camera);
			renderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			});
			renderer.setClearColor(new THREE.Color('lightgrey'), 0)
			renderer.setSize(640, 480);
			renderer.domElement.style.position = 'absolute'
			renderer.domElement.style.top = '0px'
			renderer.domElement.style.left = '0px'
			document.body.appendChild(renderer.domElement);
			clock = new THREE.Clock();
			deltaTime = 0;
			totalTime = 0;

			////////////////////////////////////////////////////////////
			// setup arToolkitSource
			////////////////////////////////////////////////////////////
			arToolkitSource = new THREEx.ArToolkitSource({
				//sourceType: 'webcam',
				sourceType:  'image',
				sourceUrl :  'Cnegra.png',	
			});
			function onResize() {
				arToolkitSource.onResize()
				arToolkitSource.copySizeTo(renderer.domElement)
				if (arToolkitContext.arController !== null) {
					arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
				}
			}
			arToolkitSource.init(function onReady() {
				onResize()
			});

			// handle resize event
			window.addEventListener('resize', function () {
				onResize()
			});

			////////////////////////////////////////////////////////////
			// setup arToolkitContext
			////////////////////////////////////////////////////////////	
			// create atToolkitContext
			arToolkitContext = new THREEx.ArToolkitContext({
				cameraParametersUrl: '../libs/data/data/camera_para.dat',
				detectionMode: 'mono'
			});

			// copy projection matrix to camera when initialization complete
			arToolkitContext.init(function onCompleted() {
				camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
			});

			/*
				for (i = 0; i < letra_object.length ; i++) {
					var loaderTexture = new THREE.MTLLoader();
					var texture = loaderTexture.load("letras/"+ letra_object[i] +"/letras.mtl", function( materials ){
			
					materials.preload();
			
					loader = new THREE.OBJLoader();
					loader.setMaterials( materials );
					loader.load("letras/"+ letra_object[i] +"/letras.obj",
						function ( model ) {
				    
						window.model = model;
						model.position.y = 0.5;
						
						model.scale.set(1,1,1)//.multiplyScalar(0.1)
						let mesh = new THREE.Mesh( model.children[0].geometry, model.children[0].material);
						array_letras_object.push(mesh);		
					});
			
				});
				}
			
				
			*/
			for (i = 0; i < array_marker_name.length; i++) {
				var markerRoot = new THREE.Group();
				markerRoot.name = array_marker_name[i];
				scene.add(markerRoot);
				let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
					type: 'pattern', patternUrl: array_marker_name[i],
				});
				const name = array_marker_name[i];
				const letra = letra_object[letra_object.indexOf(name.charAt(5))]
				console.log(name);
				console.log(i);
				console.log(letra);

				var loaderTexture = new THREE.MTLLoader();
				var texture = loaderTexture.load("letras/" + letra + "/letras.mtl", function (materials) {

					materials.preload();

					loader = new THREE.OBJLoader();
					loader.setMaterials(materials);
					console.log(name);

					console.log();
					loader.load("letras/" + letra + "/letras.obj",
						function (model) {

							window.model = model;
							model.position.y = 0.5;

							model.scale.set(1, 1, 1)//.multiplyScalar(0.1)
							let mesh = new THREE.Mesh(model.children[0].geometry, model.children[0].material);
							mesh.rotation.x = -Math.PI / 2;
							markerRoot.add(mesh);
							array_letras_object.push(mesh);
						});


					array_marker.push(markerRoot);
				});

			}
			/*
				markerRoot1 = new THREE.Group();
				markerRoot1.name = "A azul";
				scene.add(markerRoot1);
				let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
					type: 'pattern', patternUrl: "Aazul.patt",
				});
				
				markerRoot2 = new THREE.Group();
				markerRoot2.name = "A gris";
				scene.add(markerRoot2);
				let markerControls2 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot2, {
					type: 'pattern', patternUrl: "Agris.patt",
				});
			*/


		}
		var b = true;

		function update() {

			//console.log(array_marker.length);
			let visible = array_marker.filter(x => x.visible);
			console.log(visible.length);
			let order = visible.sort((x, y) => x.position.x > y.position.x);
			// console.log(visible.length);
			for (i = 0; i < visible.length; i++) {
				console.log(visible[i].name);
			}
			/*
			if (markerRoot1.visible == true){
				console.log('Marcador 1: ' +markerRoot1.position.x);
			}
			if (markerRoot2.visible == true){
				console.log('Marcador 2: '+ markerRoot2.position.x);
			}     
			*/
			// update artoolkit on every frame
			if (arToolkitSource.ready !== false)
				arToolkitContext.update(arToolkitSource.domElement);
		}
		function render() {
			renderer.render(scene, camera);
		}
		function animate() {
			requestAnimationFrame(animate);
			deltaTime = clock.getDelta();
			totalTime += deltaTime;
			update();
			render();
		}
	</script>
	</script>
</body>